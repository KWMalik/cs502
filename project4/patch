diff -urN /usr/src/linux/arch/x86/include/asm/unistd_32.h linux-2.6.37.6-0.5/arch/x86/include/asm/unistd_32.h
--- /usr/src/linux/arch/x86/include/asm/unistd_32.h	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/arch/x86/include/asm/unistd_32.h	2011-07-02 00:33:55.310163944 -0400
@@ -346,10 +346,13 @@
 #define __NR_fanotify_init	338
 #define __NR_fanotify_mark	339
 #define __NR_prlimit64		340
+#define __NR_mailbox_send	341
+#define __NR_mailbox_rcv	342
+#define __NR_mailbox_manage	343
 
 #ifdef __KERNEL__
 
-#define NR_syscalls 341
+#define NR_syscalls 344
 
 #define __ARCH_WANT_IPC_PARSE_VERSION
 #define __ARCH_WANT_OLD_READDIR
diff -urN /usr/src/linux/arch/x86/kernel/syscall_table_32.S linux-2.6.37.6-0.5/arch/x86/kernel/syscall_table_32.S
--- /usr/src/linux/arch/x86/kernel/syscall_table_32.S	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/arch/x86/kernel/syscall_table_32.S	2011-07-02 00:33:55.310163944 -0400
@@ -340,3 +340,6 @@
 	.long sys_fanotify_init
 	.long sys_fanotify_mark
 	.long sys_prlimit64		/* 340 */
+	.long sys_mailbox_send
+	.long sys_mailbox_rcv
+	.long sys_mailbox_manage
diff -urN /usr/src/linux/include/linux/mailbox.h linux-2.6.37.6-0.5/include/linux/mailbox.h
--- /usr/src/linux/include/linux/mailbox.h	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.37.6-0.5/include/linux/mailbox.h	2011-07-11 22:35:44.472000970 -0400
@@ -0,0 +1,66 @@
+/**
+* Adapted from CS-502 Project #3, Fall 2006
+*	originally submitted by Cliff Lindsay
+* Modified for CS-3013, A-term 2008
+*
+*/
+
+#ifndef __MAILBOX__
+#define __MAILBOX__
+
+#include <stdbool.h>
+#include <linux/types.h>
+
+#define NO_BLOCK false
+#define BLOCK    true
+
+#define MAX_MSG_SIZE 128
+#define CS3013_MAILBOX_SIZE 32
+
+# define alloc_CS3013_message()    ((CS3013_message *)kmem_cache_alloc(CS3013_message_cachep, GFP_KERNEL))
+# define free_CS3013_message(msg)  kmem_cache_free(CS3013_message_cachep, (msg))
+static struct kmem_cache *CS3013_message_cachep;
+
+typedef struct CS3013_mailbox {
+	struct list_head *messages;
+	bool stopped;
+	struct semaphore *empty;
+	struct semaphore *full;
+	int waitingSenders;
+	int waitingReceivers;
+} CS3013_mailbox;
+
+typedef struct CS3013_message {
+	struct list_head list;
+	pid_t sender_pid;
+	char text[MAX_MSG_SIZE];
+	int length;
+} CS3013_message;
+
+/**
+ * Functions for msgs
+ * 
+ * */
+int SendMsg(pid_t dest, void *msg, int len, bool block);
+int RcvMsg(pid_t *sender, void *msg, int *len, bool block);
+
+/**
+ * functions for maintaining mailboxes
+ * 
+ * */
+int ManageMailbox(bool stop, int *count);
+
+/**
+ * error codes pertaining to mailboxes
+ * 
+ * */
+#define MAILBOX_FULL	1001
+#define MAILBOX_EMPTY	1002
+#define MAILBOX_STOPPED	1003
+#define MAILBOX_INVALID	1004
+#define MSG_TOO_LONG	1005
+#define MSG_ARG_ERROR	1006
+#define MAILBOX_ERROR	1007
+
+#endif
+
diff -urN /usr/src/linux/include/linux/sched.h linux-2.6.37.6-0.5/include/linux/sched.h
--- /usr/src/linux/include/linux/sched.h	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/include/linux/sched.h	2011-07-02 00:33:55.318164010 -0400
@@ -1185,6 +1185,8 @@
 	perf_nr_task_contexts,
 };
 
+struct CS3013_mailbox;
+
 struct task_struct {
 	volatile long state;	/* -1 unrunnable, 0 runnable, >0 stopped */
 	void *stack;
@@ -1343,6 +1345,9 @@
 	struct files_struct *files;
 /* namespaces */
 	struct nsproxy *nsproxy;
+/* CS3013 mailbox */
+	struct CS3013_mailbox *mailbox;
+	spinlock_t mailbox_lock;
 /* signal handlers */
 	struct signal_struct *signal;
 	struct sighand_struct *sighand;
diff -urN /usr/src/linux/kernel/exit.c linux-2.6.37.6-0.5/kernel/exit.c
--- /usr/src/linux/kernel/exit.c	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/kernel/exit.c	2011-07-11 20:43:46.810901260 -0400
@@ -57,6 +57,8 @@
 #include <asm/pgtable.h>
 #include <asm/mmu_context.h>
 
+#include <linux/mailbox.h>
+
 static void exit_mm(struct task_struct * tsk);
 
 static void __unhash_process(struct task_struct *p, bool group_dead)
@@ -968,6 +970,38 @@
 	if (tsk->mm)
 		sync_mm_rss(tsk, tsk->mm);
 	group_dead = atomic_dec_and_test(&tsk->signal->live);
+
+	// if a CS3013_mailbox exists
+    if(group_dead && tsk->mailbox != NULL) {
+		CS3013_message *msg, *tmp;
+		//printk(KERN_EMERG "cleaning up mailbox for %s[%d]", tsk->comm, tsk->pid);
+		// stop CS3013_mailbox
+		tsk->mailbox->stopped = true;
+		//printk(KERN_EMERG "mailbox for %s[%d] stopped", tsk->comm, tsk->pid);
+		// up "full" semaphore for each waiting reader
+		while(tsk->mailbox->waitingReceivers > 0)
+			up(tsk->mailbox->full);
+		// up "empty" semaphore for each waiting sender
+		while(tsk->mailbox->waitingSenders > 0)
+			up(tsk->mailbox->empty);
+		//printk(KERN_EMERG "wating threads for mailbox for %s[%d] signaled", tsk->comm, tsk->pid);
+		// free unread messages
+		if(tsk->mailbox->messages != NULL) {
+			list_for_each_entry_safe(msg, tmp, tsk->mailbox->messages, list) {
+				free_CS3013_message(msg);
+			}
+			//printk(KERN_EMERG "freed message in mailbox for %s[%d]", tsk->comm, tsk->pid);
+		}
+		//printk(KERN_EMERG "freed all messages in mailbox for %s[%d]", tsk->comm, tsk->pid);
+		// free semaphores
+		kfree(tsk->mailbox->empty);
+		kfree(tsk->mailbox->full);
+		//printk(KERN_EMERG "freed semaphores in mailbox for %s[%d]", tsk->comm, tsk->pid);
+		// free CS3013_mailbox structure
+        kfree(tsk->mailbox);
+		//printk(KERN_EMERG "freed mailbox for %s[%d]", tsk->comm, tsk->pid);
+    }
+
 	if (group_dead) {
 		hrtimer_cancel(&tsk->signal->real_timer);
 		exit_itimers(tsk->signal);
diff -urN /usr/src/linux/kernel/fork.c linux-2.6.37.6-0.5/kernel/fork.c
--- /usr/src/linux/kernel/fork.c	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/kernel/fork.c	2011-07-11 20:44:06.676901000 -0400
@@ -76,6 +76,8 @@
 
 #include <trace/events/sched.h>
 
+#include <linux/mailbox.h>
+
 /*
  * Protected counters by write_lock_irq(&tasklist_lock)
  */
@@ -216,6 +218,9 @@
 	/* do the arch specific task caches init */
 	arch_task_cache_init();
 
+	// initialize CS3013_message slab allocator
+	CS3013_message_cachep = kmem_cache_create("CS3013_message", sizeof(struct CS3013_message), 0, 0, NULL);
+
 	/*
 	 * The default maximum number of threads is set to a safe
 	 * value: the thread structures can take up at most half
@@ -1453,6 +1458,36 @@
 			init_completion(&vfork);
 		}
 
+        // assign a CS3013_mailbox
+		p->mailbox = NULL;
+		if(p->mm) { // unless it's a kernel thread
+			//printk(KERN_EMERG "assigning a mailbox to %s[%d]", p->comm, p->pid);
+			if(clone_flags & CLONE_THREAD) { // just a new thread
+				//printk(KERN_EMERG "forked thread %s[%d] using mailbox of parent %s[%d]", p->comm, p->pid, current->comm, current->pid);
+				// use parent's mailbox
+				p->mailbox = current->mailbox;
+			} else {
+				//printk(KERN_EMERG "creating a new mailbox for %s[%d]", p->comm, p->pid);
+				// allocate a new mailbox
+				p->mailbox = (CS3013_mailbox *) kmalloc(sizeof(CS3013_mailbox), GFP_KERNEL);
+				p->mailbox->stopped = false;
+				// initialise semaphores
+				//printk(KERN_EMERG "initialising semaphores for mailbox for %s[%d]", p->comm, p->pid);
+				p->mailbox->empty = (struct semaphore *) kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+				sema_init(p->mailbox->empty, CS3013_MAILBOX_SIZE);
+				p->mailbox->full  = (struct semaphore *) kmalloc(sizeof(struct semaphore), GFP_KERNEL);
+				sema_init(p->mailbox->full, 0);
+				// initialise waiting lists
+				//printk(KERN_EMERG "initialising waiting lists for mailbox for %s[%d]", p->comm, p->pid);
+				p->mailbox->waitingReceivers = 0;
+				p->mailbox->waitingSenders = 0;
+				// initialise message list
+				//printk(KERN_EMERG "initialising message list for mailbox for %s[%d]", p->comm, p->pid);
+				p->mailbox->messages = NULL;
+			}
+			//printk(KERN_EMERG "successfully assigned a mailbox to %s[%d]", p->comm, p->pid);
+		}
+
 		audit_finish_fork(p);
 		tracehook_report_clone(regs, clone_flags, nr, p);
 
diff -urN /usr/src/linux/kernel/mailbox.c linux-2.6.37.6-0.5/kernel/mailbox.c
--- /usr/src/linux/kernel/mailbox.c	1969-12-31 19:00:00.000000000 -0500
+++ linux-2.6.37.6-0.5/kernel/mailbox.c	2011-07-12 01:28:04.662972014 -0400
@@ -0,0 +1,127 @@
+/* Michael Ficarra (k@wpi.edu) */
+
+#include <linux/syscalls.h>
+#include <linux/sched.h>
+#include <linux/unistd.h>
+#include <linux/string.h>
+#include <linux/slab.h>
+#include <asm/unistd.h>
+
+#include <linux/mailbox.h>
+
+// int SendMsg(pid_t dest, void *msg, int len, bool block);
+SYSCALL_DEFINE4(mailbox_send, pid_t, dest_pid, void *, usr_msg, int, len, bool, block) {
+	CS3013_message *msg;
+	int downReturn;
+	struct task_struct *dest = find_task_by_vpid(dest_pid);
+
+	if(!dest || dest == NULL || dest->mailbox == NULL) return MAILBOX_INVALID;
+	if(dest->mailbox->stopped) return MAILBOX_STOPPED;
+	if(len > MAX_MSG_SIZE) return MSG_TOO_LONG;
+
+	msg = alloc_CS3013_message();
+	if(copy_from_user(&msg->text, usr_msg, len))
+		return MSG_ARG_ERROR;
+	msg->length = len;
+	msg->sender_pid = task_pid_nr(current);
+	INIT_LIST_HEAD(&msg->list);
+
+	if(block == BLOCK) {
+		++dest->mailbox->waitingSenders;
+		downReturn = down_interruptible(dest->mailbox->empty);
+		--dest->mailbox->waitingSenders;
+		if(downReturn) return -ERESTARTSYS;
+	} else {
+		if(down_trylock(dest->mailbox->empty))
+			return MAILBOX_FULL;
+	}
+	if(dest->mailbox->stopped) {
+		up(dest->mailbox->empty);
+		return MAILBOX_STOPPED;
+	}
+
+	spin_lock(&dest->mailbox_lock);
+
+	if(dest->mailbox->messages == NULL) {
+		dest->mailbox->messages = &msg->list;
+	} else {
+		list_add_tail(&msg->list, dest->mailbox->messages);
+	}
+
+	up(dest->mailbox->full);
+	spin_unlock(&dest->mailbox_lock);
+
+	return 0;
+}
+
+// int RcvMsg(pid_t *sender, void *msg, int *len, bool block);
+SYSCALL_DEFINE4(mailbox_rcv, pid_t *, sender_pid, void *, usr_msg, int *, usr_msg_len, bool, block) {
+	CS3013_message *msg;
+	int downReturn;
+	struct task_struct *self = current;
+
+	if(self->mailbox == NULL) return MAILBOX_INVALID;
+	if(self->mailbox->stopped) return MAILBOX_STOPPED;
+
+	if(block == BLOCK) {
+		++self->mailbox->waitingReceivers;
+		downReturn = down_interruptible(self->mailbox->full);
+		--self->mailbox->waitingReceivers;
+		if(downReturn) return -ERESTARTSYS;
+	} else {
+		if(down_trylock(self->mailbox->full))
+			return MAILBOX_EMPTY;
+	}
+	if(self->mailbox->stopped) {
+		up(self->mailbox->full);
+		return MAILBOX_STOPPED;
+	}
+
+	spin_lock(&self->mailbox_lock);
+
+	// sanity check
+	if(self->mailbox->messages == NULL) {
+		spin_unlock(&self->mailbox_lock);
+		return MAILBOX_EMPTY;
+	}
+
+	msg = list_entry(self->mailbox->messages, struct CS3013_message, list);
+	if(msg->list.next == &msg->list) self->mailbox->messages = NULL;
+	else self->mailbox->messages = msg->list.next;
+	list_del(&msg->list);
+
+	up(self->mailbox->empty);
+	spin_unlock(&self->mailbox_lock);
+
+	copy_to_user(&msg->text, usr_msg, msg->length);
+	copy_to_user(&msg->sender_pid, sender_pid, sizeof(pid_t));
+	copy_to_user(&msg->length, usr_msg_len, sizeof(int));
+	free_CS3013_message(msg);
+
+	return 0;
+}
+
+// int ManageMailbox(bool stop, int *count);
+SYSCALL_DEFINE2(mailbox_manage, bool, stop, int *, usr_count) {
+	struct task_struct *self = current;
+	struct list_head *tmp;
+	int count = 0;
+
+	printk(KERN_EMERG "syscall mailbox_manage called with count 0x%08x", usr_count);
+
+	if(self->mailbox == NULL) return MAILBOX_INVALID;
+
+	if(stop) self->mailbox->stopped = true;
+
+	if(self->mailbox->messages != NULL) {
+		++count;
+		spin_lock(&self->mailbox_lock);
+		__list_for_each(tmp, self->mailbox->messages) {
+			++count;
+		}
+		spin_unlock(&self->mailbox_lock);
+	}
+	copy_to_user(&count, usr_count, sizeof(int));
+
+	return 0;
+}
Binary files /usr/src/linux/kernel/.mailbox.c.swp and linux-2.6.37.6-0.5/kernel/.mailbox.c.swp differ
diff -urN /usr/src/linux/kernel/Makefile linux-2.6.37.6-0.5/kernel/Makefile
--- /usr/src/linux/kernel/Makefile	2011-04-25 15:48:33.000000000 -0400
+++ linux-2.6.37.6-0.5/kernel/Makefile	2011-07-03 21:35:25.553337002 -0400
@@ -10,7 +10,7 @@
 	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
 	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
 	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
-	    async.o range.o jump_label.o
+	    async.o range.o jump_label.o mailbox.o
 obj-y += groups.o
 
 ifdef CONFIG_FUNCTION_TRACER
